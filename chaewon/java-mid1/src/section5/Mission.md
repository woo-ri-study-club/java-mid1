## 래퍼 클래스

---

### 1-1 기본형의 문제 및 한계

저희는 자바 공부를 시작할 때부터 수차례 "자바는 객체지향적인 언어"라고 뇌리에 새겨졌습니다. 하지만 이전에 배운 기본 타입들 중 특별한 클래스인 String을 제외하고 int, long, double 등의 기본형은
객체가 아닙니다. 객체 지향 언어에서 객체가 아니라는 것은 객체의 장점을 전혀 누릴 수가 없다는 의미와 같습니다.

객체의 장점을 다시 천천히 떠올려 봅시다. 객체 내부에 만든 메서드 호출 혹은 오버라이딩하기. 컬렉션 프레임워크로 간단하게 자료 구조 이용하기. 값이 존재하지 않는다는 의미의 null 값 사용하기 등... 단순하게
생각해도 여러 장점이 존재합니다. 그리고 기본형 타입은 이 모든 것을 할 수 없습니다. 그렇다면 정수, 실수, TF 데이터를 사용하는 동시에 객체의 장점까지 사용하려면 어떻게 해야할까요? 다음의 예시 코드를 보며
아이디어를 얻어봅시다.

의외로 접근 방식은 단순합니다. 다음의 예시 코드를 봅시다.

```java
public class MyInteger {
    private final int integerValue;

    public MyInteger(int integerValue) {
        this.integerValue = integerValue;
    }

    public MyInteger increaseValue() {
        return new MyInteger(integerValue++);
    }
}
```

기본형 정수를 필드로 갖는 새 불변 객체를 작성했습니다. 이를 통해 한 번 생성자를 통해 생성하면 integerValue 값은 변경할 수 없습니다. 그리고 외부에서 increaseValue() 메서드를 호출해서 값을
증가시킬 수도 있고 인스턴스 생성 시 null을 넣을 수도 있습니다. 이처럼 이전에 배운 불변 객체를 활용하면, 기본형 데이터를 사용하면서도 객체의 장점을 이용할 수 있습니다.

'아하, 이런 식으로 기본형을 객체로 감싸 쓸 수 있구나!' 라고 생각하시는 분도 있으실 것이고, '아니 그러면 매번 저런 클래스를 직접 하나하나 써야해?' 라고 생각하시는 분들도 있으실 겁니다. 당연한 감상이고,
자바를 만든 개발자들도 당연히 파악하고 있었습니다. 자바의 창시자들이야 말로 이런 문제를 가장 먼저 알고 있었기에, 그들은 초기 버전부터 래퍼 클래스를 만들어두었습니다. 이제 진짜로 자바에서 만든, 위와 같은 접근
방식을 이용한 기본형을 감싼 객체를 확인해봅시다.

### 1-2 래퍼 클래스의 내부

자바에서 이미 만들어 둔, 기본형을 감싼 객체를 래퍼 클래스라고 합니다.
본격적인 사용법과 내부 코드를 보기 전에, 이 래퍼 클래스의 네이밍부터 정리해봅시다.

1. 정수형

- int → Integer
- long → Long

2. 실수형

- double → Double

3. 참 거짓

- boolean → Boolean

4. 문자열

- char → Character

char 형 외에는 모두 단순히 맨 앞 글자를 대문자로 변경한 것으로, 직관적인 네이밍인 것을 확인할 수 있습니다. 이 점을 유념하고 이제 내부 코드를 봅시다. 모든 클래스를 보기에는 시간이 부족하므로, 대표적으로
Integer 클래스를 확인해봅시다.

```
public final class Integer extends Number implements Comparable<Integer>, Constable, ConstantDesc {
    ...
    private final int value;
    ...
    
    etc util method...
        }
```

실제 내부 코드는 굉장히 복잡하고 길지만, 집중할 부분은 `private final int value`입니다. 저희가 위에서 보았던 간이 코드와 동일하게 final로 선언된 `int value`를 갖습니다. 이
value를 바탕으로 여러 유틸 메서드를 제공해줍니다.

### 1-3 래퍼 클래스의 선언 방법, 박싱 & 언박싱

저희가 일반적으로 객체 인스턴스를 생성할 때를 고려해볼 때, Integer 같은 래퍼 클래스도 `new Integer(value)` 형태로 생성할 것이라고 예상할 수 있습니다. 하지만 이 예측만은 잘못되었습니다.

Integer 내의 생성자 부분입니다. 이 생성자에 붙어있는 애노테이션은 이후 버전에서 삭제될 수 있으니 더이상 사용하지 말라는 의미입니다.

```
@Deprecated(since="9", forRemoval = true)
    public Integer(int value) {
        this.value = value;
    }
```

그렇다면 생성자 없이 그러면 인스턴스를 어떻게 생성하라는 걸까요? 저희는 이전에 객체에 정의된 메서드는 동일한 객체를 새로 반환할 수 있다는 것을 경험했습니다. 이를 이용한 메서드가 래퍼 클래스에도 정의되어
있습니다. `Integer.valueOf(int or String value)`가 바로 그것입니다. 이제 우리는 `Integer newInt = Integer.valueOf(value)` 형태로 특정 값을
Integer 래퍼 클래스로 감쌀 수 있습니다. 이 행위를 박스에 포장하는 것과 유사하기 때문에 **박싱**(Boxing)이라고 합니다.

그리고 우리는 박스에 포장된 것을 다시 꺼낼 수도 있습니다. 이를 **언박싱**(Unboxing)이라고 하며 `newInt.intValue()` 같은 메서드를 통해 다시 기본형 타입으로 바꿀 수 있습니다.

### 1-4 자동 박싱

우리는 직접 래퍼 클래스를 생성할 필요 없이 자바가 미리 만들어둔 래퍼 클래스를 사용하는 방법을 알아봤습니다. 하지만 매번 `Integer.valueOf(10)`의 형태로 인스턴스를 생성하는 것은 제법 귀찮은 일이기
때문에, 자바는 한 단계 더 나아간 기능을 제공합니다. `Integer newInt = 10` 형식으로만 선언해도 컴파일러가 인스턴스 생성을 해줍니다. 언박싱도
마찬가지로, `int unboxedNewInt = newInt` 형식으로 작성하면 자동으로 수행이 됩니다.

### 1-5 주요 메서드

래퍼 클래스들은 저 마다의 객체 내에 굉장히 다양한 기능 메서드를 제공합니다. 외우기에는 굉장히 방대한 분량이고, 각 메서드마다의 사용빈도가 다르기에 저희는 가장 흔하게 사용하는 valueOf()와
parseInt()만 살펴봅시다. 두 메서드는 모두 어떤 값을 매개변수로 받아올 시 정수를 반환하지만 약간의 차이가 존재합니다. 아래 표를 참고하면 금방 차이를 파악할 수 있습니다.

|       | parseInt() | valueOf()     |
|-------|------------|---------------|
| 매개변수  | String     | String or int |
| 반환 타입 | int(기본형)   | Integer(래퍼)   |

### 1-6 래퍼 클래스 vs 기본형
지금까지 위에서 제가 말씀드린 내용만 보면 객체의 장점을 모두 누릴 수 래퍼 클래스가 만능이고 최고인 것처럼 표현이 됐습니다만 그렇지는 않습니다. 개발자는 각 상황에 맞게 기본형과 래퍼 클래스를 사용해야 합니다.

기본형은 래퍼클래스보다 성능이 좋다! 이것도 자명한 사실이지만 요즘은 컴퓨터가 워낙 좋기에 이는 미미한 차이입니다. 그렇다면 더더욱 왜? 라는 의문을 떨칠 수 없을텐데, 한 가지 예를 들어봅시다. 

유저 콘솔로부터 숫자 하나를 받아와서 그 수에 10을 더하는 간단한 기능을 생각해봅시다. 프로그램이 실행되고 유저가 별 생각없이 엔터를 연타해서 숫자를 입력해야 할 부분에서도 엔터를 눌러버렸다고 가정해봅시다. 만약 매개변수가 int라면 바로 예외가 터져 프로그램이 종료되겠지만, Integer라면 null이 들어가 다음 메서드 호출 시 NullPointException이 발생할 수 있습니다. 즉, null이 들어갈 수 있다라는 것은 로직 상황에 따라 장점이 될 수도 단점이 될 수도 있습니다! 개발자는 이런 상황이을 고려하며 유지보수에 더 유용한 방식으로 코드를 작성하는 법을 학습해야 합니다.

---

## Class 클래스 / System 클래스 / Math 클래스

---
### 2-1 Class 클래스란?
Class 클래스는 클래스들의 메타데이터를 다룹니다. Class의 이해에는 제너릭, 예외 등 저희가 배운 범위 밖의 내용에 대한 이해도 필요하기 때문에 간단하게 대략적인 기능에 대한 안내만 하겠습니다.

- 타입 정보를 얻기
- **리플렉션**
  - 클래스에 정의된 필드, 생성자, 메서드 조회 및 호출
  - `someClass.getDeclaredFields()`
  - `someClass.getDeclaredMethods()`
  - `someClass.getSuperclass()`
- **동적 로딩**과 생성
  - 동적으로 로드, 새로운 인스턴스 생성
  - `Class<SomeClass> someClass = SomeClass.class;` → `someClass.getDeclaredConstructor().newInstance();`
- 애노테이션 처리
  - 클래스에 적용된 애노테이션 조회 및 처리
  - `someClass.getAnnotations()`

### 2-2 System 클래스란?
System 클래스는 운영체제와 자바가 연관되어 있는 클래스입니다. 인스턴스를 생성할 필요가 없다는게 가장 특징적입니다. 기능 역시 다양하게 존재하지만, 주로 사용하는 부분만 확인해봅시다.

- System.in
  - 표준 입력을 관리합니다.
- System.out
  - 표준 출력을 관리합니다. 저희가 기본적으로 콘솔에 문자를 출력할 때 이용하던 부분입니다.
- System.getenv
  - 운영체제에 저장된 환경변수들을 가져옵니다.
- System.getProperties
  - 속성 값들을 가져옵니다.
  - 매개변수에 속성의 키 값을 입력하면 값을 가져옵니다.
- System.arraycopy
  - 반복문을 사용하지 않고 배열을 빠르게 복사합니다.
- System.currentTimeMillis() & System.nanoTime()
  - 현재 시각을 밀리세컨드와 나노세컨드 단위로 반환합니다.
- System.exit(0)
  - 프로그램을 강제 종료합니다.
  - 프로그램 강제 종료는 예기치 못한 오류가 발생할 가능성이 높기 때문에 가급적 사용해서는 안 됩니다.

### 2-3 Math, Random 클래스
Math 클래스는 클래스 명 그대로, 수학과 관련된 편리한 기능 메서드를 제공해주는 클래스입니다. 간단한 사칙연산, 절대값, 삼각함수, 올림, 내림 등 다양한 수학 기능을 사용할 수 있습니다.

- E (상수)
  - 자연 로그의 상수 e의 값
- PI (상수)
  - 파이 값
- 삼각함수
  - sin, cos, tan
  - asin, acos, atan
- 지수함수
  - exp
- 로그함수
  - log
  - log10
- 제곱근
  - sqrt
- 세제곱근
  - cbrt
- 올림/내림
  - ceil
  - floor
  - round
- 제곱
  - pow
- 랜덤
  - random (Random 클래스 자체 기능이 더 다양하기에 잘 사용하지 않습니다.)
- 절대값
  - abs
- 최대, 최소
  - max
  - min

Random 클래스는 Math.random()보다 더 상세한 기능을 제공해주는 난수 발생 클래스입니다. 인스턴스 생성 시, 시드 설정이 가능합니다. `random.nextInt()` 형식으로 난수 생성이 가능합니다.

- .nextInt
  - int 범위 중 난수
- .nextInt(int bound)
  - 0~bound-1 내의 난수

동일한 형식으로 nextDouble, nextLong 등의 난수 발생 메서드가 존재합니다.