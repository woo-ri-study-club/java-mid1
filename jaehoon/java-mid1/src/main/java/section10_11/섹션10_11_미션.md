## 미션

드디어 아끼는 후배의 추천으로 과제를 통과하고 면접까지 도달하였다.
그리고 면접장에서 다음과 같은 질문을 던져주었다.

> 예외처리에 대해 상세히 발표해보세요. 특히 트랜젝션 관련해서 체크드 예외와 언체크드 예외의 차이를 설명해보세요.

그럼 한번 예외처리에 대해 발표해보자!

<br>

---

## 풀이

예외 처리와 트랜잭션의 체크드 예외 vs 언체크드 예외의 차이에 대해 발표하겠습니다.

### "왜 예외 처리가 필요할까요?"
- "예외가 없다면 소프트웨어는 어떻게 동작할까요?"
- 처음엔 간단하게 보일 수도 있습니다. 예를 들어, 숫자를 입력받아 나누기를 하는 프로그램을 떠올려 보면 우리가 원하는 것은 사용자가 어떤 숫자를 입력해도 정확히 동작하는 프로그램이겠죠.
- 하지만 만약 사용자가 0을 입력한다면, 프로그램은 어떻게 될까요? 단순히 "멈춰버릴" 것입니다.
- 예외 처리는 바로 이런 **"멈춤"**에 대응하기 위한 것입니다.
- 예외가 발생했을 때 이를 탐지하고, 이를 해결하거나 다음 단계로 이어질 방법을 제시하는 것 입니다. 이를 통해 우리는 프로그램의 안정성과 신뢰성을 보장할 수 있습니다.

---

### 체크드 예외와 언체크드 예외의 차이 - "무엇이 다르냐면요"
- 예외 처리에서 가장 많이 나오는 주제 중 하나는 체크드 예외(Checked Exception)와 언체크드 예외(Unchecked Exception)입니다.
- 이 둘을 설명하고 둘의 차이를 트랙잭션을 예로들어 설명하겠습니다. 

#### 체크드 예외란?
- 체크드 예외는 `"필수적으로 처리해야만 하는 예외"`입니다.
- 개발자는 try-catch 로 잡아서 처리하거나, 상위로 던져야합니다. 그렇지 않으면 컴파일러가 컴파일할때 에러가 발생합니다. 
- 컴파일러가 이건 너가 처리해야해!! 라고 강제하는거죠.
- 예를들어, `SQLException` 같은 체크드 예외가 발생합니다.
- 자바 컴파일러는 체크드 예외를 반드시 처리하도록 강제합니다. 이로 인해 `"안전한 코드"`를 작성할 수 있게 도와줍니다.

#### 언체크드 예외란?
- 반면, 언체크드 예외는 컴파일러가 강제하지 않습니다.
- 주로 프로그래머의 실수나 예측하기 어려운 상황에서 발생합니다.
- 이경우에는 예외가 발생하더라도, throws로 명시하지 않아도 자동으로 상위로 던져집니다.
- 예를 들어, `NullPointerException`은 객체가 null인지 확인하지 않아 발생합니다.
- 이는 런타임에서 탐지되고, 프로그래머가 코드를 주의 깊게 설계해야만 합니다.

---

### 트랜잭션에서의 예외처리 - "안정성을 위한 선택"
- 트랜잭션 처리에서 체크드 예외와 언체크드 예외는 각각 다른 방식으로 동작하며, 이에 따른 전략도 달라집니다.

#### 체크드 예외
- 기본적으로 스프링 트랜잭션 관리는 체크드 예외가 발생하더라도 트랜잭션을 롤백하지 않습니다. (그러나 꼭 롤백을 하지 않는다. 라고만 보면 안됩니다.!!)
  - 체크드 예외는 명시적으로 처리해야하므로 예외를 잡아내서(catch) (A)가 실패했을때 대안적으로 처리할 로직 (B)가 존재할 수 있다고 봅니다. 
  - 쉽게 말해 스프링은 체크드 예외를 개발자가 예외를 복구하거나 적절히 처리할 것이라고 가정합니다.
- 예를 들어, SQLException이나 IOException 같은 체크드 예외는 추가로 처리할 수 있도록 트랜잭션 롤백을 강제하지 않는다가 정확합니다.

#### 체크드 예외 롤백을 위한 방법

1. `언체크드 예외로 감싸기: 체크드 예외를 런타임 예외로 변환해 트랜잭션 롤백을 유도할 수도 있습니다`
```java
public void yourMethod() throws Exception {
  try {
    // 비즈니스 로직
    throw new Exception("Checked Exception");
  } catch (Exception e) {
    throw new RuntimeException(e); // 언체크드 예외로 감싸기
  }
}
```

2. `rollbackFor 속성: 명시적으로 처리할 예외를 지정하여, 체크드 예외도 롤백을 수행하도록 설정할 수 있습니다.`
```java
import org.springframework.transaction.annotation.Transactional;

@Transactional(rollbackFor = {Exception.class}) // Exception이 발생하면 트랜잭션이 롤백됨
public void yourMethod() throws Exception {
    // 비즈니스 로직
    throw new Exception("Checked Exception 발생!");
}
```

#### 언체크드 예외
- 언체크드 예외는 런타임 시점에 발생하며, 기본적으로 스프링은 트랜잭션 롤백을 수행합니다.
  - 예: NullPointerException, IllegalArgumentException.
- 언체크드 예외는 예측하기 어려운 상황이나 코드 설계 문제에서 발생하며, 개발자가 미리 이를 방지해야 합니다.
  - 예를 들어, 데이터가 null인 상태로 데이터베이스에 저장하려다 실패하는 경우입니다.
- 스프링 트랜잭션은 이러한 예외를 복구하지 않고 자동으로 트랜잭션을 롤백합니다.
  - 이는 문제 해결이 불가능하다고 판단하고, 시스템 상태를 원복하려는 설계입니다.

`
트랜잭션에서의 체크드 예외, 언체크드 예외가 어떤식으로 설계되어 동작되고 있는지 확인하면 두 예외의 의도가 더 명확하게 들어나지 않나요?
`

`
단지 롤백한다, 롤백안한다의 차이로 보면 안됩니다.!! 롤백은 옵션의 문제일뿐 예외 상황을 어떻게 처리하도록 유도할 것인지가 더 중요한 문제입니다. 
`

---

### 왜 예외 처리 메커니즘이 중요한가?
- 결국, 예외 처리는 `"프로그램을 신뢰할 수 있게 만드는 핵심 메커니즘"`입니다.
- 체크드 예외를 통해 예상 가능한 문제를 강제적으로 처리하고, 언체크드 예외를 통해 런타임에서 유연성을 확보할 수 있습니다.

---

### 마무리하며 - "예외 처리를 어떻게 대해야 할까?"
- 예외 처리는 단순히 문제를 피하기 위한 것이 아닙니다.
- 오히려 시스템의 신뢰성을 높이고, 코드 설계와 유지보수성을 강화하는 중요한 방법입니다.
- 특히 트랜잭션과 같은 중요한 로직에서는 체크드 예외와 언체크드 예외를 적절히 사용해 안정성과 효율성을 동시에 추구해야 합니다.