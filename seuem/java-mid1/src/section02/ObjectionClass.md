# Object Class

객체들은 extends를 이용해서 다른 클래스를 상속을 받을 수 있잖아.

상속 받으면 부모 클래스안에 있는 매서드들(기능)을 자손 클래스가 사용할수도 있고 

오버라이딩이라는 기능을 이용해서 부모 클래스에 선언된 메서드를 재정의해서 사용할도 수 있어. 선언된 메서드의 이름은 같지만 메서드 안을 내용을 수정하는 것야.

Object 클래스는 모든 객체의 부모 클래스여서 객체에 상속받는 부모 클래스가 없다면 자바는 묵시적으로 Object 클래스를 상속을해

그래서 extends Object라고 선언되있지 않아도 모든 객체들는 Object클래스에 정의된 메서드들을 사용할수있지.

.toString 도 Object클래스에 선언된 메서드라서 모든 객체들은 .toString 메서드를 사용할수있고 

또 overriding을 사용해서 .toString 메서드를 자손클래스에서 재정의해서 사용할수있어!

.toString은 원래는 String으로 클래스정보랑 참조값(주소)반환하는데 

자손클래스에서 IDE사용해서 .toString을 오버라이딩 해주면 자동으로 메서드안이 수정되어서 객체안에 있는 변수들 정보를 String으로 반환해줘.


# Object클래스를 최상위 클래스에 둔 이유

모든 객체들의 제일 머리 위에 하나의 클래스인 Object클래스를 둔 이유는.. 
공통 기능 제공이랑 다형성을 가능하게 하기 위해서야.


Object 클래스에 모든 객체가 필요한 기본 기능들을 두어서 객체는 편리하게 Object 클래스가 제공하는 기능을 사용할 수 있어. 
편리하기도 하고 객체들 마다 특성이 다르니 공통으로 재공하는 메서드를 오버라이딩해서 객체의 특성에 맞게 수정할수도 있잖아.
그때 Object클래스가 제공하는 기본 메서드들을 자손클래스(객체)에서 재정의 (오버라이딩) 했을데도 
객체들 마다 서로 다른 메서드 이름이 아닌 공통의 메서드를 가지니까 개발자들 사이에서도 서로 코드 읽기도 편해지잖아! 협업도 수월해지구..

Object 클래스가 다형성을 가능하게 한다고 했잖아!
메서드의 파라미터에 Object 타입을 두면 모든 객체를 인수로 받을수있어. 
타입이 다른 객체를 한곳에 담아야한다면 Object 타입을 사용하면 되.
이게 객체지향의 설계원칙인 SOLID의 OCP-변경엔 닫혀있고 확장에 열렸는 원칙을 지키는거지.

그러니까 메서드를 만들때 메서드 안으로 들어오는 클래스 타입을 파라미터에 정의 해주야하잖아. 
나중에 파라미터로 들어오는 클래스가 변경이나 추가될 가능성이 있을 경우에 구체적인 클래스 타입을 정의하면 메서드의 파라미터를 수정해야하잖아 이러면 안대!!!
변경 안돼!!! 삡!! OCP위반!! >_< 낄낄
에햄.. 아무튼 구체적인 타입에 의존하지않고 추상적인 최상위 클래스인 Object타입에 의존하면 나중에 추가로 객체들을 확장할떄도 클래스의 객체만 추가로 만들고
공통으로 객체들을 다루는 메서드는 변경할필요가 없는거지.
배열도 Object로 선언하면 모든 객체를 다 담을수있어..!

메서드의 파라미터에 Object클래스타입으로 선언하면 메서드안에서 특정 구체 클래스를 사용할떄는 촘 문제가 있긴 한데! 
파라미터를 Object로 받아서 어떤 객체가 들어왔는지 모르잖아 그냥 Object클래스가 상속받은것만 알구...
특정 구체클래스의 메서드가 있을수도 있구 없을수도 있는거지.. 
instanceOf를 사용해서 파라미터로 받은 이 객체가 특정 클래스인지 확인하고 다시 다운캐스팅하면 객체가 특정 클래스타입일때 그 클래스의 메서드를 사용할수있어.
예를 들면 Object 클래스에는 eat라는 메서드가 없지. 

강아지 객체가 메서드의 파라미터로 들어오면 강아지의 eat메서드를 쓰려면 먼저 이 객체가 강아지 클래스인지 확인한뒤에 다운캐스팅해서 사용하는거얌.. 

자세한건 구글링 해보도록해.. 

오히려 적당한 틀을 만들어줘서 더 자유롭게 사용할수있다는게 신기하쿤.. 
바구니 큰거 하나 만들어주니 이것저것 담을수있는 느낌이당




