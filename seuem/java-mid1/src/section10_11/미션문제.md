## 미션

드디어 아끼는 후배의 추천으로 과제를 통과하고 면접까지 도달하였다. 그리고 면접장에서 다음과 같은 질문을 던져주었다.

> 예외처리에 대해 상세히 발표해보세요. 특히 트랜젝션 관련해서 체크드 예외와 언체크드 예외의 차이를 설명해보세요.

그럼 한번 예외처리에 대해 발표해보자!

## 예외처리의 필요성
- 프로그램에 에러가 생겼을때 예외를 관리 해주는 방법이다.

예외 계층의 최상위 객체는 다른 객체와 마찬가지로 Object class이다. 

Object class를 상속 받은 Throwable 객채는 예외 클래스의 최상위 객체이다.

Exception class와 Error class가 Throwable class를 상속받는다. 

Error class는 메모리 복구와 같은 복구가 불가능한 시스템 예외기 떄문에 이 예외를 잡을수 없다.
(예외 객체들은 상속 관계라서 throwable을 사용해서 예외를 잡으려 하면 그 하위에 시스템예외인 Error 클래스의 예외까지 잡기 떄문에 예외는 Exception부터 하위 객체들만 사용해야한다.)


Throwable을 상속받은 Exception class는 SQLException, IOException, RuntimeException 객체들을 하위에 두고 있다.

RuntimeException은 언체크 예외이고 Exception과 SQLException, IOException은 체크 예외이다.

체크 예외는 개발자가 명시적으로 throws로 처리해주지 않으면 컴파일 오류가 난다. 언체크 예외는 명시해주지 않아도 된다.

예외처리는 두가지 방법이 있는데 하나는 밖으로 에러를 넘기는거고(체크예외는 throws를 사용하고 언체크는 자동으로 넘겨준다)
또 하나는 try catch 문을 사용해서 에러가 발생했을때 대처해주는것이다.

밑에 코드는 체크예외와 언체크예외이다. 

# 체크예외 예제)

```java
//exception을 상속받은 예외 클래스.(exception을 상속받았으니 체크예외이다.)
public class MyCheckedException extends Exception {
    public MyCheckedException(String message) {
        super(message);
    }
}
```

```java
//체크 예외는 예외 클래스를 사용하는 곳에 꼭 throws를 사용해서 코드에 명시해줘야한다.
public class Client {
    public void call() throws MyCheckedException { //throws는 명시적 체크예외일때 사용.(에외를 밖으로 던질때 사용)
        throw new MyCheckedException("ex");//throw는 예외를 생성할때 사용.
    }
}
```

언체크 예외는 (runtimeException) throws를 명시 해주지 않아도 에러가 발생하면 밖으로 던져준다.

# 언체크예외 예제)
```java
//RuntimeException을 상속받은 예외 클래스.(RuntimeException을 상속받았으니 언체크예외이다.)
public class MyCheckedException extends RuntimeException {
    public MyCheckedException(String message) {
        super(message);
    }
}
```

```java
//언체크 예외는 예외 클래스를 사용하는 곳에 throws를 명시하지않는다.
public class Client {
    public void call() { //throws는 명시하지않아도 에외상황이 발생하면 밖으로 던진다)
        throw new MyCheckedException("ex");//throw는 예외를 생성할때 사용해야한다. throw new 사용!
    }
}
```

체크예외는 정말 중요한 예외가 있을떄 사용해서 누락되지않게 관리하고 보통은 언체크예외로 사용한다.

스프링에서는 트랜젝션 안에서 자동으로 체크예외가 발생되었을때 롤백하지 않고 언체크 예외는 롤백해준다고 한다. (필요에 의해 재설정할 수 있음) 

--------------------------------
# finally 

프로그램에서 에러가 발생됐을때와 발생되지 않았을때 동일하게 후에 실행되어야 할 코드가 있다면 try catch문과 함께 finally를 사용한다.
```java
try { //정상 흐름
    
} catch() { //예외 흐름 
    
} finally { //반드시 호출해야 하는 마무리 흐름 
    
}
```
** catch문에서 잡을수 없는 예외가 발생할때도 finally는 실행된다! *-*b  그럴때에는 finally가 수행된 후 예외를 밖으로 던진다.

```java
try {//정상 흐름
    
} finally { //그래서 catch문 없이 try finally로만도 사용된다. 
    // 오류를 밖으로 던지되 그전에 수행해야할것들은 fianlly에서 실행된다.
}
```
----
# 계층화된 catch문
예외클래스많고 예외마다 각자 다른 처리가 필요할 경우, 더 세밀하게 예외를 처리할수있고 또 특정예외는 묶어서 한꺼번에 처리할 수 있다.

### 계층형 catch 문
- 이건 순서대로 체크하기 떄문에 부모예외 객체를 앞순서에 두면 그뒤에 있는 자손예외는 예외로 잡히지 않기 떄문에
자손예외를 앞순서에 두어 예외를 잘 캐치할수있게 한다.
```java
try { //정상 흐름
    
} catch(MyCheckedException e) { 
    
} catch(Exception e) { 
    
}
```
### 한 catch문 안에 두개의 예외 클래스를 잡기
- 두 예외 모두 처리 방식이나 로그에 남겨야하는게 같다면 유용하지만 예외객체마다 다른 특성이 있다면 따로해서 명확하게 예외를 처리하는게 더 옳은 방법이다 (사용자에 필요이상으로 디테일한 오류상태를 알려주지 않는다.)
```java
try { //정상 흐름
    
} catch(MyCheckedException | MyUncheckedException e) { 
    //안에 실행되는게 같아야한다. 
    
} catch(Exception e) { 
    
}
```
--------------

복구할수없는 예외라면 밖으로 다 던진뒤에 한꺼번에 받아서 exceptionHandler메서드에 보내준다
exceptionHandler메서드에서 instanceOf를 사용해서 특정 예외에 대한 로그도 남겨서
버깅이 쉽도록 한다.
```java
try {
     networkService.sendMessage(input);
} catch (Exception e) { // 모든 예외를 잡아서 처리 
    exceptionHandler(e); //<---메서드를 만들어준다.
}
```

```java
//공통 예외 처리
private static void exceptionHandler(Exception e) {
//공통 처리
System.out.println("사용자 메시지: 죄송합니다. 알 수 없는 문제가 발생했습니다.");
System.out.println("==개발자용 디버깅 메시지==");
e.printStackTrace(System.out); // 스택 트레이스 출력 
// e.printStackTrace(); // System.err에 스택 트레이스 출력
//필요하면 예외 별로 별도의 추가 처리 가능
if (e instanceof MyCheckedException chex) {
System.out.println("[전송 오류] 전송 데이터: " + chex.getcheckedData()); }
}
```
----
# try-with-resources(자바7부터 도입)
finally보다 더 코드가 간결해지고 가독성과 스코프 범위도 줄일수있는게 try-with-resource이다.

애플리케이션이 외부 자원을 사용할경우 반드시 사용후 해제해줘야한다.

try catch문에서 finally을 없애고 try()가로 안에 객체를 생성한뒤 {}안에서 메서드들을 실행한다. 그리구 finally안에 들어갈 코드를 객체안에 넣어준다.(객체에 AutoCloseable 인터페이스를 구현하면 가능하다.)

```java
try{
    
    }catch{
    
        }finally{
    
        }; //위에는 finally 사용;
```

```java
try(){
    
    }catch{
    
        }; //위에는 try() 사용;
```



### try-with-resources 예제-

```java

//try()안에 리소스를 생성하면 생성된 객체의 스코프도 낭비하지않고 필요한 범위까지만 관리되고 finally 없이
//리소스 객체안에 스코프가 끝날때 호출될 메서드도 자동으로 실행되게 할수있다.
try (NetworkClient networkClient= new NetworkClient(input)){
     networkClient.sendMessage(input);
} catch (Exception e) { // 모든 예외를 잡아서 처리 
    exceptionHandler(e); 
}
```
### AutoCloseable 인테페이스
NetworkClient 클래스에 AutoCLoseable 인터페이스를 구현해준다.
AutoCloseable 인터페이스를 구현하면 try문이 다 끝나면 바로 실행된다.
```java
package java.lang;
public interface AutoCloseable {
    void close() throws Exception;
}

```
```java
 public class NetworkClient implements AutoCloseable {//이렇게 AutoCloseable을 implement받고
    //
    //NetworkClient 코드들...
    //
    //
    
    
    @Override
    public void close() { 
        //AutoCloseable 인터페이스가 제공하는 Close()안에 finally에서 실행하던 코드를 넣어주면 된다.
        System.out.println("NetworkClient.close");
        disconnect();
    }
    
 }

```

### 단독으로 대처가 필요한 예외는 런타임으로 잡아서 대처하고 나머지의 대처할 수 없는 예외들은 하나로 묶어서 ExceptionHandler 공통처리 메서드로 로그를 남긴다. 필요할시 InstanceOf를 사용해서 디버깅에 쉽게 로그를 남긴다.






